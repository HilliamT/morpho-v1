diff -ruN common/rewards-distribution/MerkleTree1.sol common/rewards-distribution/MerkleTree1.sol
--- common/rewards-distribution/MerkleTree1.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/MerkleTree1.sol	2022-12-13 15:33:55.871080178 +0100
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+import "./MerkleTree.sol";
+
+contract MerkleTree1 is MerkleTree {}
diff -ruN common/rewards-distribution/MerkleTree2.sol common/rewards-distribution/MerkleTree2.sol
--- common/rewards-distribution/MerkleTree2.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/MerkleTree2.sol	2022-12-13 15:33:55.881080214 +0100
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+import "./MerkleTree.sol";
+
+contract MerkleTree2 is MerkleTree {}
diff -ruN common/rewards-distribution/MerkleTree.sol common/rewards-distribution/MerkleTree.sol
--- common/rewards-distribution/MerkleTree.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/MerkleTree.sol	2022-12-13 16:36:28.726254289 +0100
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+abstract contract MerkleTree {
+    struct Node {
+        bool inTree;
+        address left;
+        address right;
+        uint256 value;
+        bytes32 hashNode;
+    }
+
+    mapping(address => Node) public nodes;
+
+    address public root;
+
+    function hash(address addr) public view returns (bytes32) {
+        return nodes[addr].hashNode;
+    }
+
+    function wellFormed(address addr) public view returns (bool) {
+        Node storage node = nodes[addr];
+
+        if (!node.inTree) return false;
+
+        if (node.left == address(0) && node.right == address(0))
+            return
+                node.value != 0 && node.hashNode == keccak256(abi.encodePacked(addr, node.value));
+        else {
+            // Well-formed nodes have exactly 0 or 2 children.
+            if (node.left == address(0) || node.right == address(0)) return false;
+            bytes32 leftHash = nodes[node.left].hashNode;
+            bytes32 rightHash = nodes[node.right].hashNode;
+            return
+                node.value == 0 &&
+                leftHash <= rightHash && // Well-formed nodes should be pair sorted.
+                node.hashNode == keccak256(abi.encode(leftHash, rightHash));
+        }
+    }
+
+    function notEmpty() public view returns (bool) {
+        return nodes[root].inTree;
+    }
+
+    function _valueFrom(address user, address addr) private view returns (uint256) {
+        if (root == address(0)) return 0;
+        if (user == addr) return nodes[addr].value;
+        uint256 foundLeft = _valueFrom(user, nodes[addr].left);
+        uint256 foundRight = _valueFrom(user, nodes[addr].right);
+        return foundLeft > foundRight ? foundLeft : foundRight;
+    }
+
+    function value(address user) public view returns (uint256) {
+        return _valueFrom(user, root);
+    }
+}
diff -ruN .gitignore .gitignore
--- .gitignore	1970-01-01 01:00:00.000000000 +0100
+++ .gitignore	2022-12-13 15:33:55.881080214 +0100
@@ -0,0 +1 @@
+*
