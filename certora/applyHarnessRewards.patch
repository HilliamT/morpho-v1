diff -ruN common/rewards-distribution/MerkleTree1.sol common/rewards-distribution/MerkleTree1.sol
--- common/rewards-distribution/MerkleTree1.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/MerkleTree1.sol	2022-12-13 21:34:36.870605662 +0100
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+import "./MerkleTree.sol";
+
+contract MerkleTree1 is MerkleTree {}
diff -ruN common/rewards-distribution/MerkleTree2.sol common/rewards-distribution/MerkleTree2.sol
--- common/rewards-distribution/MerkleTree2.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/MerkleTree2.sol	2022-12-13 21:34:36.870605662 +0100
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+import "./MerkleTree.sol";
+
+contract MerkleTree2 is MerkleTree {}
diff -ruN common/rewards-distribution/MerkleTree.sol common/rewards-distribution/MerkleTree.sol
--- common/rewards-distribution/MerkleTree.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/MerkleTree.sol	2022-12-13 21:34:36.870605662 +0100
@@ -0,0 +1,101 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+contract MerkleTree {
+    struct Node {
+        bool created;
+        address left;
+        address right;
+        uint256 value;
+        bytes32 hashNode;
+    }
+
+    mapping(address => Node) public nodes;
+
+    address public root;
+
+    bool public initialized;
+
+    constructor() {
+        require(initialized == false);
+        initialized = true;
+    }
+
+    function isCreated(address addr) public view returns (bool) {
+        return nodes[addr].created;
+    }
+
+    function newAccount(address _user, uint256 _value) public {
+        Node storage node = nodes[_user];
+        require(!node.created);
+
+        node.created = true;
+        node.value = _value;
+        node.hashNode = keccak256(abi.encodePacked(_user, _value));
+    }
+
+    // function newNode(
+    //     address parent,
+    //     address left,
+    //     address right
+    // ) public {
+    //     Node storage parentNode = nodes[parent];
+    //     Node storage leftNode = nodes[left];
+    //     Node storage rightNode = nodes[right];
+    //     require(!parentNode.created);
+    //     require(leftNode.created && rightNode.created);
+    //     require(leftNode.hashNode <= rightNode.hashNode);
+
+    //     parentNode.created = true;
+    //     parentNode.left = left;
+    //     parentNode.right = right;
+    //     parentNode.hashNode = keccak256(abi.encode(leftNode.hashNode, rightNode.hashNode));
+    // }
+
+    function setRoot(address addr) public {
+        require(nodes[addr].created);
+        root = addr;
+    }
+
+    function hash(address addr) public view returns (bytes32) {
+        return nodes[addr].hashNode;
+    }
+
+    function isWellFormed(address addr) public view returns (bool) {
+        Node storage node = nodes[addr];
+
+        if (!node.created) return true;
+
+        if (node.left == address(0) && node.right == address(0))
+            return
+                node.value != 0 && node.hashNode == keccak256(abi.encodePacked(addr, node.value));
+        else {
+            // Well-formed nodes have exactly 0 or 2 children.
+            if (node.left == address(0) || node.right == address(0)) return false;
+            Node storage left = nodes[node.left];
+            Node storage right = nodes[node.right];
+            return
+                left.created &&
+                right.created &&
+                node.value == 0 &&
+                left.hashNode <= right.hashNode && // Well-formed nodes should be pair sorted.
+                node.hashNode == keccak256(abi.encode(left.hashNode, right.hashNode));
+        }
+    }
+
+    function notEmpty() public view returns (bool) {
+        return nodes[root].created;
+    }
+
+    function _valueFrom(address user, address addr) private view returns (uint256) {
+        if (root == address(0)) return 0;
+        if (user == addr) return nodes[addr].value;
+        uint256 foundLeft = _valueFrom(user, nodes[addr].left);
+        uint256 foundRight = _valueFrom(user, nodes[addr].right);
+        return foundLeft > foundRight ? foundLeft : foundRight;
+    }
+
+    function value(address user) public view returns (uint256) {
+        return _valueFrom(user, root);
+    }
+}
diff -ruN .gitignore .gitignore
--- .gitignore	1970-01-01 01:00:00.000000000 +0100
+++ .gitignore	2022-12-13 21:34:36.870605662 +0100
@@ -0,0 +1 @@
+*
